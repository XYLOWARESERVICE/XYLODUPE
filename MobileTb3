-- Xyloware Safe Dupe UI - Purple Glowing Version
-- AUTO-SCALING BASED ON DEVICE
-- Wait for services
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
-- Services
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")

-- Unanchors before physics (allows full movement), anchors after (anti-detection)
local function setupNewAntiTP()
    local character = player.Character or player.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    RunService.PreSimulation:Connect(function()
        if rootPart and rootPart.Parent then
            rootPart.Anchored = false
        end
    end)

    RunService.PostSimulation:Connect(function()
        if rootPart and rootPart.Parent then
            rootPart.Anchored = true
        end
    end)

    -- Reconnect on respawn
    player.CharacterAdded:Connect(function(newChar)
        rootPart = newChar:WaitForChild("HumanoidRootPart")
    end)
end

-- Start the new anti-TP immediately
task.spawn(setupNewAntiTP)

-- Device detection and scaling function
local function getDeviceInfo()
    local screenSize = GuiService:GetScreenResolution()
    local aspectRatio = screenSize.X / screenSize.Y
    local isTouch = UserInputService.TouchEnabled
   
    local deviceType, uiScale, buttonScale, textScale
   
    if isTouch then
        -- Mobile devices
        if aspectRatio >= 0.55 and aspectRatio <= 0.6 then
            deviceType = "Phone_Tall" -- iPhone, most phones
            uiScale = 0.85
            buttonScale = 1.25
            textScale = 1.15
        elseif aspectRatio > 0.6 and aspectRatio <= 0.67 then
            deviceType = "Phone_Wide" -- Some Android phones
            uiScale = 0.9
            buttonScale = 1.2
            textScale = 1.1
        elseif aspectRatio > 0.67 and aspectRatio <= 0.75 then
            deviceType = "Tablet" -- iPads, tablets
            uiScale = 1.1
            buttonScale = 1.15
            textScale = 1.08
        else
            deviceType = "Mobile_Other"
            uiScale = 1.0
            buttonScale = 1.2
            textScale = 1.1
        end
    else
        -- Desktop devices
        local totalPixels = screenSize.X * screenSize.Y
       
        if totalPixels >= 3840 * 2160 then -- 4K
            deviceType = "Desktop_4K"
            uiScale = 1.4
            buttonScale = 1.1
            textScale = 1.2
        elseif totalPixels >= 2560 * 1440 then -- 2K/QHD
            deviceType = "Desktop_QHD"
            uiScale = 1.3
            buttonScale = 1.05
            textScale = 1.15
        elseif totalPixels >= 1920 * 1080 then -- Full HD
            deviceType = "Desktop_FHD"
            uiScale = 1.2
            buttonScale = 1.0
            textScale = 1.1
        elseif totalPixels >= 1366 * 768 then -- HD
            deviceType = "Desktop_HD"
            uiScale = 1.0
            buttonScale = 1.0
            textScale = 1.0
        else -- Low resolution
            deviceType = "Desktop_LowRes"
            uiScale = 0.9
            buttonScale = 0.95
            textScale = 0.95
        end
    end
   
    return {
        deviceType = deviceType,
        screenSize = screenSize,
        aspectRatio = aspectRatio,
        isTouch = isTouch,
        uiScale = uiScale,
        buttonScale = buttonScale,
        textScale = textScale
    }
end
-- Get device info
local deviceInfo = getDeviceInfo()
local isMobile = deviceInfo.isTouch
-- Print device info to console
print("ðŸ“± Device Info:")
print(" Type:", deviceInfo.deviceType)
print(" Screen:", deviceInfo.screenSize.X, "x", deviceInfo.screenSize.Y)
print(" Aspect Ratio:", string.format("%.2f:1", deviceInfo.aspectRatio))
print(" UI Scale:", deviceInfo.uiScale .. "x")
print(" Button Scale:", deviceInfo.buttonScale .. "x")
print(" Text Scale:", deviceInfo.textScale .. "x")
-- Remotes
local InventoryEvent = ReplicatedStorage:FindFirstChild("Inventory")
-- Variables
local AutoSafeDupeEnabled = false
local AutoSafeDupeThread = nil
local SafeCooldown = false
local SafeTargetWeapon = nil
local glowAnimationEnabled = true
local uiVisible = true
-- Notification helper for F9 menu
local function F9Notification(text)
    print("ðŸ“¢ " .. text)
end
-- Function to reset all cooldowns
local function resetAllCooldowns()
    SafeCooldown = false
    if AutoSafeDupeThread then
        task.cancel(AutoSafeDupeThread)
        AutoSafeDupeThread = nil
    end
    AutoSafeDupeEnabled = false
    F9Notification("All cooldowns reset!")
end
-- Function to count weapon copies
local function countWeaponCopies(weaponName)
    local count = 0
   
    if player.Character then
        if player.Character:FindFirstChild(weaponName) then
            count = count + 1
        end
    end
   
    if player.Backpack then
        for _, item in pairs(player.Backpack:GetChildren()) do
            if item.Name == weaponName then
                count = count + 1
            end
        end
    end
   
    return count
end
-- Find weapon to dupe for safe
local function findWeaponToDupeForSafe()
    local Character = player.Character
    if not Character then return nil end
    if SafeTargetWeapon then
        local targetTool = Character:FindFirstChild(SafeTargetWeapon)
        if targetTool then return targetTool end
        local Backpack = player.Backpack
        if Backpack then
            local targetInBackpack = Backpack:FindFirstChild(SafeTargetWeapon)
            if targetInBackpack then
                local Humanoid = Character:FindFirstChild("Humanoid")
                if Humanoid then
                    Humanoid:EquipTool(targetInBackpack)
                    task.wait(0.2)
                    return Character:FindFirstChild(SafeTargetWeapon)
                end
            end
        end
    end
    return Character:FindFirstChildOfClass("Tool")
end
-- Store weapons in closest safe (when you have exactly 2 copies)
local function autoSafeWeapons()
    if InventoryEvent and SafeTargetWeapon then
        local weaponCount = countWeaponCopies(SafeTargetWeapon)
       
        if weaponCount == 2 then
            local character = player.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then
                return false, "Character not ready"
            end
           
            local playerPosition = character.HumanoidRootPart.Position
            local closestSafe = nil
            local shortestDistance = math.huge
            local maxDistance = 50 -- Maximum distance to consider a safe
           
            -- Find all safes within the map
            local map = workspace["1# Map"]
            if not map then
                return false, "Map not found"
            end
           
            -- Look for models that are likely safes by name or characteristics
            local allSafes = {}
           
            -- Search for models with safe-like names
            for _, model in pairs(map:GetDescendants()) do
                if model:IsA("Model") then
                    -- Check if model name indicates it's a safe
                    local modelName = string.lower(model.Name)
                    if modelName:find("safe") or modelName:find("gunstorage") or modelName:find("weaponstorage") then
                        -- Find the main part of the safe (usually largest part or named "Part")
                        local mainPart = nil
                        local largestSize = 0
                       
                        for _, part in pairs(model:GetChildren()) do
                            if part:IsA("BasePart") then
                                -- Check if this looks like a safe door/main part
                                local partSize = part.Size.X * part.Size.Y * part.Size.Z
                               
                                -- Prioritize parts named "Part" or parts that are metal
                                if part.Name == "Part" or part.Material == Enum.Material.Metal then
                                    if partSize > largestSize then
                                        largestSize = partSize
                                        mainPart = part
                                    end
                                end
                               
                                -- If we haven't found a main part yet, use any base part
                                if not mainPart then
                                    mainPart = part
                                end
                            end
                        end
                       
                        if mainPart then
                            table.insert(allSafes, {model = model, part = mainPart})
                        end
                    end
                end
            end
           
            -- If no safes found by name, look for models with specific characteristics
            if #allSafes == 0 then
                for _, model in pairs(map:GetDescendants()) do
                    if model:IsA("Model") then
                        -- Look for models that might be safes based on their parts
                        local hasMetalPart = false
                        local hasLockIndicator = false
                        local mainPart = nil
                       
                        for _, part in pairs(model:GetChildren()) do
                            if part:IsA("BasePart") then
                                -- Check for metal parts (common in safes)
                                if part.Material == Enum.Material.Metal then
                                    hasMetalPart = true
                                    if not mainPart or part.Name == "Part" then
                                        mainPart = part
                                    end
                                end
                               
                                -- Check for parts that might indicate a lock or safe
                                if part.Name:find("Lock") or part.Name:find("Door") or part.Name:find("Handle") then
                                    hasLockIndicator = true
                                end
                               
                                -- If no metal part yet, use any part
                                if not mainPart then
                                    mainPart = part
                                end
                            end
                        end
                       
                        -- If it has metal parts or lock indicators, it might be a safe
                        if mainPart and (hasMetalPart or hasLockIndicator) then
                            table.insert(allSafes, {model = model, part = mainPart})
                        end
                    end
                end
            end
           
            -- Find the closest safe
            for _, safeData in pairs(allSafes) do
                local distance = (playerPosition - safeData.part.Position).Magnitude
                if distance < shortestDistance and distance <= maxDistance then
                    shortestDistance = distance
                    closestSafe = safeData.model -- Store the model, not the part
                end
            end
           
            if closestSafe then
                InventoryEvent:FireServer("Change", SafeTargetWeapon, "Backpack", closestSafe)
                return true, "Stored " .. SafeTargetWeapon .. " in closest safe (" .. math.floor(shortestDistance) .. " studs away)"
            else
                -- Fallback to original specific safe if no close safe found
                local containers = map:GetChildren()
                if #containers >= 968 then
                    local container = containers[968]
                    if container then
                        local containerChildren = container:GetChildren()
                        if #containerChildren >= 5 then
                            local targetChild = containerChildren[5]
                            if targetChild then
                                InventoryEvent:FireServer("Change", SafeTargetWeapon, "Backpack", targetChild)
                                return true, "Stored " .. SafeTargetWeapon .. " in default safe (no close safe found)"
                            end
                        end
                    end
                end
                return false, "No safe found within " .. maxDistance .. " studs"
            end
        else
            return false, "Not storing " .. SafeTargetWeapon .. " (Have " .. weaponCount .. " copies, need exactly 2)"
        end
    end
    return false, "Safe remote not found"
end
-- Main safe dupe function
local function performSafeDupe()
    if SafeCooldown then
        F9Notification("Cooldown active!")
        return false, "Cooldown active"
    end
    local Character = player.Character
    if not Character then
        return false, "Character not found"
    end
    local Tool = findWeaponToDupeForSafe()
    if not Tool then
        return false, "No weapon found! Hold a weapon"
    end
    if not SafeTargetWeapon then
        SafeTargetWeapon = Tool.Name
        F9Notification("Target set: " .. SafeTargetWeapon)
    end
    local Humanoid = Character:FindFirstChild("Humanoid")
    if Humanoid then
        Humanoid:UnequipTools()
        task.wait(0.2)
    end
    local ToolName = Tool.Name
    local ToolId = nil
    local Connection
    Connection = ReplicatedStorage.MarketItems.ChildAdded:Connect(function(item)
        if item.Name == ToolName then
            if item:WaitForChild("owner").Value == player.Name then
                ToolId = item:GetAttribute("SpecialId")
            end
        end
    end)
    SafeCooldown = true
    ReplicatedStorage.ListWeaponRemote:FireServer(ToolName, 1000000)
    task.wait(0.26)
    ReplicatedStorage.BackpackRemote:InvokeServer("Store", ToolName)
    task.wait(3)
    if ToolId then
        ReplicatedStorage.BuyItemRemote:FireServer(ToolName, "Remove", ToolId)
    else
        pcall(function()
            ReplicatedStorage.BuyItemRemote:FireServer(ToolName, "Remove")
        end)
    end
    ReplicatedStorage.BackpackRemote:InvokeServer("Grab", ToolName)
    if Connection then
        Connection:Disconnect()
    end
    task.wait(1)
    local Backpack = player.Backpack
    if Backpack then
        local toolInBackpack = Backpack:FindFirstChild(ToolName)
        if toolInBackpack and Humanoid then
            Humanoid:EquipTool(toolInBackpack)
        end
    end
    SafeCooldown = false
    return true, "Safe dupe completed: " .. ToolName
end
-- Auto grab weapons for safe
local function autoGrabWeaponsForSafe()
    local Character = player.Character
    if not Character then return end
   
    local Humanoid = Character:FindFirstChild("Humanoid")
    local Backpack = player.Backpack
   
    if Humanoid and Backpack then
        Humanoid:UnequipTools()
        task.wait(0.2)
       
        if SafeTargetWeapon then
            local targetTool = Backpack:FindFirstChild(SafeTargetWeapon)
            if targetTool then
                Humanoid:EquipTool(targetTool)
                task.wait(0.2)
            end
        end
    end
end
-- Start auto safe dupe
local function startAutoSafeDupeMacro()
    if AutoSafeDupeEnabled then
        stopAutoSafeDupeMacro()
        return
    end
   
    AutoSafeDupeEnabled = true
    F9Notification("ðŸ”’ Auto Safe Dupe STARTED!")
    AutoSafeDupeThread = task.spawn(function()
        while AutoSafeDupeEnabled do
            local success, message = performSafeDupe()
           
            if success then
                F9Notification(message)
                task.wait(1)
               
                -- Grab weapons after dupe
                autoGrabWeaponsForSafe()
               
                -- Check and store in closest safe if exactly 2 copies
                local safeSuccess, safeMsg = autoSafeWeapons()
                if safeSuccess then
                    F9Notification(safeMsg)
                else
                    F9Notification(safeMsg)
                end
            else
                F9Notification(message)
            end
           
            if AutoSafeDupeEnabled then
                task.wait(5)
            end
        end
    end)
end
-- Stop auto safe dupe
local function stopAutoSafeDupeMacro()
    AutoSafeDupeEnabled = false
    if AutoSafeDupeThread then
        task.cancel(AutoSafeDupeThread)
        AutoSafeDupeThread = nil
    end
    F9Notification("ðŸ›‘ Auto Safe Dupe STOPPED!")
end
-- Reset target weapon
local function resetTargetWeapon()
    if SafeTargetWeapon then
        local previousWeapon = SafeTargetWeapon
        SafeTargetWeapon = nil
        F9Notification("Target reset: " .. previousWeapon)
    else
        F9Notification("No target to reset")
    end
end
-- Teleport to closest safe (on top of it) - SILENT VERSION
local function teleportToClosestSafe()
    local Character = player.Character
    if not Character then
        return
    end
   
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then
        return
    end
   
    local playerPosition = HumanoidRootPart.Position
    local closestSafe = nil
    local closestSafePart = nil
    local shortestDistance = math.huge
   
    -- Find all safes in the map
    local map = workspace["1# Map"]
    if not map then
        return
    end
   
    -- Look for models that are definitely safes by name
    for _, model in pairs(map:GetDescendants()) do
        if model:IsA("Model") then
            local modelName = string.lower(model.Name)
           
            -- Only look for objects with "safe" in the name to avoid teleporting to random objects
            if modelName:find("safe") or modelName:find("gunstorage") or modelName:find("weaponstorage") then
                -- Find the main/largest part of the safe
                local mainPart = nil
                local largestSize = 0
               
                for _, part in pairs(model:GetChildren()) do
                    if part:IsA("BasePart") then
                        local partSize = part.Size.X * part.Size.Y * part.Size.Z
                       
                        -- Prioritize parts named "Part" (common for safes)
                        if part.Name == "Part" then
                            if partSize > largestSize then
                                largestSize = partSize
                                mainPart = part
                            end
                        end
                       
                        -- If no "Part" found, use largest metal part
                        if not mainPart and part.Material == Enum.Material.Metal then
                            if partSize > largestSize then
                                largestSize = partSize
                                mainPart = part
                            end
                        end
                       
                        -- If still no main part, use largest part
                        if not mainPart then
                            if partSize > largestSize then
                                largestSize = partSize
                                mainPart = part
                            end
                        end
                    end
                end
               
                if mainPart then
                    local distance = (playerPosition - mainPart.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestSafe = model
                        closestSafePart = mainPart
                    end
                end
            end
        end
    end
   
    if closestSafePart then
        -- Calculate position on top of the safe
        local safeHeight = closestSafePart.Size.Y
        local teleportHeight = safeHeight + 3 -- 3 studs above the safe
       
        -- Get the top center of the safe
        local teleportPosition = closestSafePart.Position + Vector3.new(0, teleportHeight, 0)
       
        -- Create a CFrame that's upright (no rotation)
        local teleportCFrame = CFrame.new(teleportPosition)
       
        -- Teleport to the top of the safe
        HumanoidRootPart.CFrame = teleportCFrame
    else
        -- Fallback to original coordinates
        local safeCFrame = CFrame.new(-185.01, 295.40, -994.84)
        HumanoidRootPart.CFrame = safeCFrame
    end
end
-- Fire proximity prompt function
local function _fireproximityprompt(prompt)
    fireproximityprompt(prompt)
end
-- Simple teleport function for MAX MONEY - SILENT VERSION
local function Teleport(cframe, instant)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        if instant then
            player.Character.HumanoidRootPart.CFrame = cframe
        else
            player.Character.HumanoidRootPart.CFrame = cframe
        end
    end
end
-- MAX MONEY Function (replaces manual stop)
local function maxMoneyFunction()
    F9Notification("Starting MAX MONEY script...")
   
    -- Check if player has Ice-Fruit Cupz
    local function GetFruitCup()
        local Found, Cup = false, nil
       
        -- Check in backpack
        for _, item in player.Backpack:GetChildren() do
            if item:IsA("Tool") and item.Name == "Ice-Fruit Cupz" then
                if item:FindFirstChild("IceFruit Cup") and item["IceFruit Cup"]:FindFirstChild("IceFruit PunchMedium") then
                    if item["IceFruit Cup"]["IceFruit PunchMedium"].Transparency ~= 1 then
                        Found = true
                        Cup = item
                        break
                    end
                end
            end
        end
       
        -- Check in character
        if not Found and player.Character then
            for _, item in player.Character:GetChildren() do
                if item:IsA("Tool") and item.Name == "Ice-Fruit Cupz" then
                    if item:FindFirstChild("IceFruit Cup") and item["IceFruit Cup"]:FindFirstChild("IceFruit PunchMedium") then
                        if item["IceFruit Cup"]["IceFruit PunchMedium"].Transparency ~= 1 then
                            Found = true
                            Cup = item
                            break
                        end
                    end
                end
            end
        end
       
        return Found, Cup
    end
   
    local Found, Cup = GetFruitCup()
   
    if Cup and Found then
        F9Notification("Selling existing fruit cup...")
       
        local OLDCFrame = player.Character.HumanoidRootPart.CFrame
       
        if Cup.Parent == player.Backpack then
            player.Character.Humanoid:EquipTool(Cup)
            task.wait(1)
        end
       
        Teleport(Workspace["IceFruit Sell"].CFrame, true)
        task.wait(.5)
       
        for i = 1, 4000 do
            task.spawn(function()
                _fireproximityprompt(Workspace["IceFruit Sell"].ProximityPrompt)
            end)
        end
       
        Teleport(OLDCFrame)
        F9Notification("Sold existing fruit cup!")
        return
    end
   
    -- If no cup, make one and sell
    F9Notification("Making and selling fruit cup...")
   
    local OLDCFrame = player.Character.HumanoidRootPart.CFrame
   
    local Itemz = {"FijiWater", "FreshWater", "Ice-Fruit Bag", "Ice-Fruit Cupz"}
    local Stove = nil
   
    -- Find available stove
    for _, pot in Workspace.CookingPots:GetChildren() do
        if pot:IsA("Model") then
            local prompt = pot:FindFirstChildWhichIsA("ProximityPrompt", true)
            if prompt and prompt.ActionText == "Turn On" and prompt.Enabled then
                Stove = pot
                break
            end
        end
    end
   
    if not Stove then
        F9Notification("No available stove found!")
        return
    end
   
    -- Buy needed items
    for _, item in pairs(Itemz) do
        if not player.Backpack:FindFirstChild(item) then
            ReplicatedStorage:WaitForChild("ExoticShopRemote"):InvokeServer(item)
            task.wait(1)
        end
    end
   
    -- Check if all items were bought
    local Check = false
    for _, item in pairs(Itemz) do
        if not player.Backpack:FindFirstChild(item) then
            Check = true
        end
    end
   
    if Check then
        F9Notification("Shop out of stock! Wait a few minutes.")
        return
    end
   
    -- Cook the fruit cup
    Teleport(Stove:FindFirstChild("CookPart") and Stove.CookPart.CFrame or Stove.PrimaryPart.CFrame, true)
    task.wait(1)
   
    -- Hide backpack UI temporarily
    StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
    player.Character.HumanoidRootPart.Anchored = true
    task.wait(1.5)
   
    -- Turn on stove
    local stovePrompt = Stove:FindFirstChildWhichIsA("ProximityPrompt", true)
    if stovePrompt then
        fireproximityprompt(stovePrompt)
    end
    task.wait(2)
   
    -- Add ingredients
    for _, item in pairs({"FijiWater", "FreshWater", "Ice-Fruit Bag"}) do
        player.Character.Humanoid:EquipTool(player.Backpack[item])
        task.wait(1)
        if stovePrompt then
            fireproximityprompt(stovePrompt)
        end
        task.wait(3)
    end
   
    -- Wait for cooking to finish
    repeat task.wait() until
    not (Stove:FindFirstChild("CookPart") and Stove.CookPart:FindFirstChild("Steam") and
         Stove.CookPart.Steam:FindFirstChild("LoadUI") and Stove.CookPart.Steam.LoadUI.Enabled)
   
    -- Add cup
    if not player.Character:FindFirstChild("Ice-Fruit Cupz") then
        player.Character.Humanoid:EquipTool(player.Backpack['Ice-Fruit Cupz'])
        task.wait(1)
    end
   
    task.wait(1)
   
    -- Take cup from stove
    if stovePrompt then
        fireproximityprompt(stovePrompt)
    end
    task.wait(3)
   
    player.Character.HumanoidRootPart.Anchored = false
   
    -- Teleport to sell point
    Teleport(Workspace["IceFruit Sell"].CFrame, true)
    task.wait(1)
   
    player.Character.HumanoidRootPart.Anchored = true
    task.wait(1.5)
   
    -- Equip cup if not equipped
    if not player.Character:FindFirstChild("Ice-Fruit Cupz") then
        player.Character.Humanoid:EquipTool(player.Backpack['Ice-Fruit Cupz'])
        task.wait(1)
    end
   
    -- Set prompt to instant sell
    if Workspace["IceFruit Sell"]:FindFirstChild("ProximityPrompt") then
        Workspace["IceFruit Sell"].ProximityPrompt.HoldDuration = 0
    end
   
    -- Mass sell
    for i = 1, 4000 do
        task.spawn(function()
            _fireproximityprompt(Workspace["IceFruit Sell"].ProximityPrompt)
        end)
    end
   
    -- Clean up
    player.Character.HumanoidRootPart.Anchored = false
    StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
    task.wait(0.5)
   
    Teleport(OLDCFrame, true)
    task.wait(2)
   
    F9Notification("MAX MONEY process completed!")
end
-- Now create the Purple Glowing UI with toggle button and dynamic scaling
local function createMobileFriendlyUI()
    -- Create main ScreenGui
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "XylowareSafeDupeUI"
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.ResetOnSpawn = false
   
    -- Remove existing UI
    local existingUI = playerGui:FindFirstChild("XylowareSafeDupeUI")
    if existingUI then
        existingUI:Destroy()
    end
   
    ScreenGui.Parent = playerGui
   
    -- Calculate sizes based on device
    local baseToggleSize = 40
    local baseUISize = 350
    local baseTextSize = 18
    local baseButtonHeight = 50
    local baseButtonText = 16
   
    -- Apply device scaling
    local toggleSize = baseToggleSize * deviceInfo.buttonScale
    local uiSize = baseUISize * deviceInfo.uiScale
    local toggleTextSize = baseTextSize * deviceInfo.textScale
    local buttonHeight = baseButtonHeight * deviceInfo.buttonScale
    local buttonTextSize = baseButtonText * deviceInfo.textScale
   
    -- Create toggle button (always visible)
    local ToggleButton = Instance.new("TextButton")
    ToggleButton.Name = "ToggleButton"
    ToggleButton.Text = "X" -- Old English style X
    ToggleButton.Font = Enum.Font.GothamBlack
    ToggleButton.TextSize = toggleTextSize
    ToggleButton.TextColor3 = Color3.fromRGB(180, 100, 255)
    ToggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    ToggleButton.BorderColor3 = Color3.fromRGB(80, 40, 150)
    ToggleButton.BorderSizePixel = 2
    ToggleButton.Position = UDim2.new(0, 10, 0, 10)
    ToggleButton.Size = UDim2.new(0, toggleSize, 0, toggleSize)
    ToggleButton.ZIndex = 100
   
    -- Add corner rounding
    local ToggleCorner = Instance.new("UICorner")
    ToggleCorner.CornerRadius = UDim.new(0, 6)
    ToggleCorner.Parent = ToggleButton
   
    -- Add glow to toggle button
    local ToggleGlow = Instance.new("Frame")
    ToggleGlow.Name = "ToggleGlow"
    ToggleGlow.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
    ToggleGlow.BackgroundTransparency = 0.8
    ToggleGlow.BorderSizePixel = 0
    ToggleGlow.Size = UDim2.new(1, 0, 1, 0)
    ToggleGlow.ZIndex = -1
    ToggleGlow.Parent = ToggleButton
   
    local ToggleGlowCorner = Instance.new("UICorner")
    ToggleGlowCorner.CornerRadius = UDim.new(0, 6)
    ToggleGlowCorner.Parent = ToggleGlow
   
    ToggleButton.Parent = ScreenGui
   
    -- Main Frame (Square, mobile-friendly)
    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
    MainFrame.BorderColor3 = Color3.fromRGB(40, 40, 40)
    MainFrame.BorderSizePixel = 2
    
    -- FIXED: Center-left bottom corner positioning
    if isMobile then
        -- For mobile, position it in center-left bottom corner
        -- Position: Left side (5% from left), centered vertically on bottom half (70% from top)
        MainFrame.Position = UDim2.new(0.05, 0, 0.7, -uiSize/2)
    else
        -- For desktop, keep it centered
        MainFrame.Position = UDim2.new(0.5, -uiSize/2, 0.5, -uiSize/2)
    end
    
    MainFrame.Size = UDim2.new(0, uiSize, 0, uiSize)
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    MainFrame.Visible = false -- Start hidden
    MainFrame.Parent = ScreenGui
    -- Outer glow
    local OuterGlow = Instance.new("Frame")
    OuterGlow.Name = "OuterGlow"
    OuterGlow.BackgroundColor3 = Color3.fromRGB(80, 40, 150)
    OuterGlow.BackgroundTransparency = 0.7
    OuterGlow.BorderSizePixel = 0
    OuterGlow.Position = UDim2.new(-0.02, 0, -0.02, 0)
    OuterGlow.Size = UDim2.new(1.04, 0, 1.04, 0)
    OuterGlow.ZIndex = -1
    OuterGlow.Parent = MainFrame
    local OuterCorner = Instance.new("UICorner")
    OuterCorner.CornerRadius = UDim.new(0, 8)
    OuterCorner.Parent = OuterGlow
    -- Main frame corner
    local MainCorner = Instance.new("UICorner")
    MainCorner.CornerRadius = UDim.new(0, 6)
    MainCorner.Parent = MainFrame
    -- Top Bar
    local TopBar = Instance.new("Frame")
    TopBar.Name = "TopBar"
    TopBar.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    TopBar.BorderSizePixel = 0
    TopBar.Size = UDim2.new(1, 0, 0, 50 * deviceInfo.buttonScale)
    TopBar.Parent = MainFrame
    -- Title Container
    local TitleContainer = Instance.new("Frame")
    TitleContainer.Name = "TitleContainer"
    TitleContainer.BackgroundTransparency = 1
    TitleContainer.Size = UDim2.new(1, 0, 1, 0)
    TitleContainer.Parent = TopBar
    -- Main Title (Glowing Purple)
    local TitleLabel = Instance.new("TextLabel")
    TitleLabel.Name = "TitleLabel"
    TitleLabel.Text = "Xylo Dupe"
    TitleLabel.Font = Enum.Font.GothamBlack
    TitleLabel.TextSize = (isMobile and 22 or 20) * deviceInfo.textScale
    TitleLabel.TextColor3 = Color3.fromRGB(180, 100, 255)
    TitleLabel.BackgroundTransparency = 1
    TitleLabel.Size = UDim2.new(0.7, 0, 0.6, 0)
    TitleLabel.Position = UDim2.new(0.15, 0, 0.2, 0)
    TitleLabel.Parent = TitleContainer
    -- Subtitle
    local SubtitleLabel = Instance.new("TextLabel")
    SubtitleLabel.Name = "SubtitleLabel"
    SubtitleLabel.Text = "Dupe&Max Money"
    SubtitleLabel.Font = Enum.Font.GothamBold
    SubtitleLabel.TextSize = (isMobile and 14 or 12) * deviceInfo.textScale
    SubtitleLabel.TextColor3 = Color3.fromRGB(160, 90, 240)
    SubtitleLabel.BackgroundTransparency = 1
    SubtitleLabel.Position = UDim2.new(0.15, 0, 0.6, 0)
    SubtitleLabel.Size = UDim2.new(0.7, 0, 0.4, 0)
    SubtitleLabel.Parent = TitleContainer
    -- Close button in UI
    local closeBtnSize = 25 * deviceInfo.buttonScale
    local CloseButton = Instance.new("TextButton")
    CloseButton.Name = "CloseButton"
    CloseButton.Text = "âœ•"
    CloseButton.Font = Enum.Font.GothamBold
    CloseButton.TextSize = (isMobile and 20 or 18) * deviceInfo.textScale
    CloseButton.TextColor3 = Color3.fromRGB(255, 120, 120)
    CloseButton.BackgroundColor3 = Color3.fromRGB(40, 20, 40)
    CloseButton.BorderColor3 = Color3.fromRGB(100, 40, 100)
    CloseButton.BorderSizePixel = 2
    CloseButton.Position = UDim2.new(1, -(closeBtnSize + 15), 0, 10)
    CloseButton.Size = UDim2.new(0, closeBtnSize, 0, closeBtnSize)
    CloseButton.Parent = TopBar
    local CloseCorner = Instance.new("UICorner")
    CloseCorner.CornerRadius = UDim.new(0, 6)
    CloseCorner.Parent = CloseButton
    -- Content Area
    local ContentArea = Instance.new("Frame")
    ContentArea.Name = "ContentArea"
    ContentArea.BackgroundTransparency = 1
    ContentArea.Position = UDim2.new(0, 15, 0, 60 * deviceInfo.buttonScale)
    ContentArea.Size = UDim2.new(1, -30, 1, -(75 * deviceInfo.buttonScale))
    ContentArea.Parent = MainFrame
    -- Buttons Container with scrolling for mobile
    local ButtonsContainer = Instance.new("ScrollingFrame")
    ButtonsContainer.Name = "ButtonsContainer"
    ButtonsContainer.BackgroundTransparency = 1
    ButtonsContainer.Size = UDim2.new(1, 0, 1, 0)
    ButtonsContainer.CanvasSize = UDim2.new(0, 0, 0, 240 * deviceInfo.buttonScale)
    ButtonsContainer.ScrollBarThickness = (isMobile and 6 or 4) * deviceInfo.buttonScale
    ButtonsContainer.ScrollBarImageColor3 = Color3.fromRGB(100, 50, 200)
    ButtonsContainer.Parent = ContentArea
    -- Function to create glowing button (mobile-friendly)
    local function createGlowingButton(name, text, positionY, halfWidth)
        local scaledButtonHeight = buttonHeight
        local scaledTextSize = buttonTextSize
       
        local ButtonFrame = Instance.new("Frame")
        ButtonFrame.Name = name .. "ButtonFrame"
        ButtonFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
        ButtonFrame.BorderColor3 = Color3.fromRGB(80, 40, 150)
        ButtonFrame.BorderSizePixel = 2
       
        if halfWidth then
            ButtonFrame.Position = UDim2.new(0, 0, 0, positionY * deviceInfo.buttonScale)
            ButtonFrame.Size = UDim2.new(0.48, 0, 0, scaledButtonHeight)
        else
            ButtonFrame.Position = UDim2.new(0, 0, 0, positionY * deviceInfo.buttonScale)
            ButtonFrame.Size = UDim2.new(1, 0, 0, scaledButtonHeight)
        end
       
        ButtonFrame.Parent = ButtonsContainer
       
        local ButtonCorner = Instance.new("UICorner")
        ButtonCorner.CornerRadius = UDim.new(0, 6)
        ButtonCorner.Parent = ButtonFrame
       
        -- Button glow
        local ButtonGlow = Instance.new("Frame")
        ButtonGlow.Name = "ButtonGlow"
        ButtonGlow.BackgroundColor3 = Color3.fromRGB(100, 50, 200)
        ButtonGlow.BackgroundTransparency = 0.8
        ButtonGlow.BorderSizePixel = 0
        ButtonGlow.Size = UDim2.new(1, 0, 1, 0)
        ButtonGlow.ZIndex = -1
        ButtonGlow.Parent = ButtonFrame
       
        local GlowCorner = Instance.new("UICorner")
        GlowCorner.CornerRadius = UDim.new(0, 6)
        GlowCorner.Parent = ButtonGlow
       
        -- Button label
        local ButtonLabel = Instance.new("TextLabel")
        ButtonLabel.Name = name .. "ButtonLabel"
        ButtonLabel.Text = text
        ButtonLabel.Font = Enum.Font.GothamSemibold
        ButtonLabel.TextSize = scaledTextSize
        ButtonLabel.TextColor3 = Color3.fromRGB(200, 160, 255)
        ButtonLabel.BackgroundTransparency = 1
        ButtonLabel.Size = UDim2.new(1, 0, 1, 0)
        ButtonLabel.Parent = ButtonFrame
       
        -- Button
        local Button = Instance.new("TextButton")
        Button.Name = name .. "Button"
        Button.Text = ""
        Button.BackgroundTransparency = 1
        Button.Size = UDim2.new(1, 0, 1, 0)
        Button.Parent = ButtonFrame
       
        -- Hover effects (only on desktop)
        if not isMobile then
            Button.MouseEnter:Connect(function()
                ButtonFrame.BackgroundColor3 = Color3.fromRGB(40, 30, 60)
                ButtonFrame.BorderColor3 = Color3.fromRGB(120, 70, 220)
            end)
           
            Button.MouseLeave:Connect(function()
                ButtonFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
                ButtonFrame.BorderColor3 = Color3.fromRGB(80, 40, 150)
            end)
        end
       
        return Button, ButtonLabel, ButtonFrame
    end
    -- Create buttons
    local button1, label1, frame1 = createGlowingButton("Auto", "ðŸ”’ AUTO SAFE DUPE", 0, false)
    local button2, label2, frame2 = createGlowingButton("ResetTarget", "ðŸ—‘ï¸ RESET TARGET", 65, true)
    local button3, label3, frame3 = createGlowingButton("Teleport", "ðŸ“ TP CLOSEST SAFE", 65, true)
    local button4, label4, frame4 = createGlowingButton("MaxMoney", "ðŸ’° MAX MONEY", 130, false)
    local button5, label5, frame5 = createGlowingButton("Reset", "ðŸ”„ RESET COOLDOWN", 195, false)
    -- Position the half-width buttons side by side
    frame2.Position = UDim2.new(0, 0, 0, 65 * deviceInfo.buttonScale)
    frame2.Size = UDim2.new(0.48, 0, 0, buttonHeight)
   
    frame3.Position = UDim2.new(0.52, 0, 0, 65 * deviceInfo.buttonScale)
    frame3.Size = UDim2.new(0.48, 0, 0, buttonHeight)
    -- Button functions
    button1.MouseButton1Click:Connect(function()
        if AutoSafeDupeEnabled then
            stopAutoSafeDupeMacro()
            label1.Text = "ðŸ”’ AUTO SAFE DUPE"
            frame1.BorderColor3 = Color3.fromRGB(80, 40, 150)
        else
            startAutoSafeDupeMacro()
            label1.Text = "ðŸ›‘ STOP SAFE DUPE"
            frame1.BorderColor3 = Color3.fromRGB(255, 80, 80)
        end
    end)
   
    button2.MouseButton1Click:Connect(function()
        resetTargetWeapon()
    end)
   
    button3.MouseButton1Click:Connect(function()
        teleportToClosestSafe()
    end)
   
    button4.MouseButton1Click:Connect(function()
        maxMoneyFunction()
    end)
   
    button5.MouseButton1Click:Connect(function()
        resetAllCooldowns()
    end)
    -- Close button in UI function
    CloseButton.MouseButton1Click:Connect(function()
        MainFrame.Visible = false
        uiVisible = false
        ToggleButton.TextColor3 = Color3.fromRGB(180, 100, 255)
        ToggleButton.BorderColor3 = Color3.fromRGB(80, 40, 150)
    end)
    -- Toggle button function
    local function toggleUI()
        uiVisible = not uiVisible
        MainFrame.Visible = uiVisible
       
        -- Change toggle button text/color when UI is visible
        if uiVisible then
            ToggleButton.TextColor3 = Color3.fromRGB(255, 100, 100)
            ToggleButton.BorderColor3 = Color3.fromRGB(255, 80, 80)
        else
            ToggleButton.TextColor3 = Color3.fromRGB(180, 100, 255)
            ToggleButton.BorderColor3 = Color3.fromRGB(80, 40, 150)
        end
    end
    ToggleButton.MouseButton1Click:Connect(toggleUI)
    -- Draggable functionality for main frame
    local dragging, dragInput, dragStart, startPos
    local function update(input)
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    TopBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = MainFrame.Position
           
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    TopBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)
    -- Draggable functionality for toggle button
    local toggleDragging, toggleDragInput, toggleDragStart, toggleStartPos
    ToggleButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            toggleDragging = true
            toggleDragStart = input.Position
            toggleStartPos = ToggleButton.Position
           
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    toggleDragging = false
                end
            end)
        end
    end)
    ToggleButton.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            toggleDragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == toggleDragInput and toggleDragging then
            local delta = input.Position - toggleDragStart
            ToggleButton.Position = UDim2.new(toggleStartPos.X.Scale, toggleStartPos.X.Offset + delta.X, toggleStartPos.Y.Scale, toggleStartPos.Y.Offset + delta.Y)
        end
    end)
    -- Glowing animation for main UI
    local glowIntensity = 0
    local glowDirection = 1
    local glowConnection
    local function startGlowAnimation()
        if glowConnection then
            glowConnection:Disconnect()
        end
       
        glowConnection = RunService.RenderStepped:Connect(function(deltaTime)
            if not uiVisible then return end
           
            glowIntensity = glowIntensity + (deltaTime * glowDirection * 2)
           
            if glowIntensity > 1 then
                glowIntensity = 1
                glowDirection = -1
            elseif glowIntensity < 0.3 then
                glowIntensity = 0.3
                glowDirection = 1
            end
           
            -- Pulsing glow for title
            local glowColor = Color3.fromRGB(
                math.floor(180 * glowIntensity),
                math.floor(100 * glowIntensity),
                math.floor(255 * glowIntensity)
            )
           
            TitleLabel.TextColor3 = glowColor
           
            -- Pulsing glow for frame
            local frameGlow = Color3.fromRGB(
                math.floor(80 * (0.5 + glowIntensity * 0.5)),
                math.floor(40 * (0.5 + glowIntensity * 0.5)),
                math.floor(150 * (0.5 + glowIntensity * 0.5))
            )
           
            OuterGlow.BackgroundColor3 = frameGlow
            OuterGlow.BackgroundTransparency = 0.7 - (glowIntensity * 0.2)
        end)
    end
    -- Start glow animation
    startGlowAnimation()
   
    -- Cleanup when ScreenGui is destroyed
    ScreenGui.Destroying:Connect(function()
        if glowConnection then
            glowConnection:Disconnect()
        end
    end)
   
    return ScreenGui, ToggleButton, MainFrame
end
-- Create the UI
local success, result = pcall(createMobileFriendlyUI)
if success then
    F9Notification("ðŸ”’ Auto Safe Dupe Loaded")
    F9Notification("ðŸ“± Device: " .. deviceInfo.deviceType)
    F9Notification("ðŸ–¼ï¸ Screen: " .. deviceInfo.screenSize.X .. "x" .. deviceInfo.screenSize.Y)
    F9Notification("âš–ï¸ UI Scale: " .. deviceInfo.uiScale .. "x")
    print("âœ… Safe Dupe UI loaded successfully with auto-scaling!")
else
    local errMsg = tostring(result)
    F9Notification("Failed to load UI: " .. errMsg)
    warn("âŒ Failed to load UI:", errMsg)
end
